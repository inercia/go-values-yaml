### Argo CD repository organization (LLM-oriented, concise)

Goal: GitOps repo is the source of truth. Argo CD pulls desired state (from Git) and reconciles clusters.

Core objects

- Application: Points to repo/path/revision and target cluster/namespace.
- ApplicationSet: Generates many Applications from a template (per env/cluster/dir).
- AppProject: Groups apps and enforces allowed sources/destinations/resources.

Typical layout

- `apps/`: Argo CD Application/ApplicationSet specs (often includes a root “app of apps”).
- `projects/`: AppProject definitions.
- `infra/`: Platform components as apps (ingress, cert-manager, monitoring, logging).
- `services/<service>/` or `apps/<app>/`: Manifests per workload.
  - `base/`: env-agnostic Kustomize base or chart defaults
  - `overlays/<env>/`: env-specific differences (dev/stage/prod)
- `helm/` or `charts/` (optional): local Helm charts and values files.

### Helm values.yaml in Argo CD (structure, organization, precedence)

What values.yaml is

- Input data for Helm templates. It is not a Kubernetes object; it configures how the chart renders manifests.

Typical contents

- Image and rollout: `image.repository`, `image.tag`, `replicaCount`, probes, autoscaling
- Networking: `service.*`, `ingress.*` (hosts, TLS)
- Resources and scheduling: `resources`, `nodeSelector`, `tolerations`, `affinity`
- Storage: `persistence.*`, PVC sizes, storageClass
- App config: environment variables, flags, config files, annotations/labels, sidecars
- Security: `securityContext`, `podSecurityContext`, `serviceAccount`
- Cross-chart: `global.*` for values shared by subcharts

Structure

- YAML mapping with nested maps/lists. Types must be preserved across layers.
- Lists replace (not merge) when overridden. Maps deep-merge. Scalars replace.
- Avoid implicit types for strings like "on/yes/no"; quote them.

Organization patterns in Git

- Per environment files: `values/values-dev.yaml`, `values-staging.yaml`, `values-prod.yaml`
- Per cluster/tenant: `values/cluster-<name>.yaml`, `values/tenant-<name>.yaml`
- Place value files alongside the chart path used by the Application so relative paths resolve.
- Example layering order (rightmost wins): `[values.yaml, values-dev.yaml, values-cluster-usw2.yaml, values-tenant-acme.yaml]`

Argo CD source specifics

- Git chart source (repoURL + path): `spec.source.helm.valueFiles` are relative to `spec.source.path`.
- Helm repo chart source: external value files from your Git cannot be referenced; use inline `values`/`valuesObject`/`parameters` instead.
- Highest precedence comes from `spec.source.helm.valuesObject`/`values` and `parameters` (like `--set`).

Subcharts and `global`

- Configure subcharts under their name (e.g., `postgresql.enabled: false`). Use `global.*` to share values across subcharts.

Secrets

- Do not commit plaintext secrets. Use SOPS-encrypted values files or external secret stores and reference via templates.

Validation and CI

- Prefer charts with `values.schema.json` for validation.
- In CI, render with all intended value files: `helm template` and/or `helm lint`, then validate against Kubernetes schemas (e.g., kubeconform).

Editing guidance for tools (important for this library)

- Preserve data types exactly; avoid unintended stringification of numbers/bools.
- Respect merge semantics: map deep-merge, list replace, scalar replace.
- Maintain deterministic key ordering only for readability; YAML order is not semantically meaningful.
- Keep comments if possible but never depend on them for logic.
- Ensure `valueFiles` order is preserved in Applications; later files override earlier ones.

Short example values.yaml

```yaml
replicaCount: 2
image:
  repository: ghcr.io/org/app
  tag: "1.4.0"
service:
  type: ClusterIP
  port: 8080
ingress:
  enabled: true
  className: nginx
  hosts:
    - host: app.dev.example.com
      paths:
        - path: /
          pathType: Prefix
resources:
  requests: { cpu: 100m, memory: 128Mi }
  limits:   { cpu: 500m, memory: 512Mi }
```
