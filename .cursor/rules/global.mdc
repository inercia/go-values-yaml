---
alwaysApply: false
---

### Argo CD repository organization (concise, LLM-oriented)

Goal: A GitOps repo is the single source of truth for the desired state of one or more Kubernetes clusters. Argo CD pulls (not pushes), compares live vs. desired, and reconciles drift.

Core building blocks
- Applications: Argo CD `Application` objects point to a repo/path/revision and a destination cluster/namespace.
- ApplicationSets: Generate many `Application` objects from a template (e.g., per cluster, per environment, per directory).
- AppProjects: Group and guardrails for apps (allowed sources, destinations, namespaces, cluster-scoped resources).
- Manifests: Typically rendered by Kustomize or Helm, then applied by Argo CD.

Common repo patterns
- App-of-Apps: Root repo contains `Application`(s) that bootstrap all other apps (infra, platforms, business apps).
- Environment-centric: `environments/<env>/...` overlays drive per-env differences; often managed by an `ApplicationSet`.
- Per-app repos: Each app keeps its own manifests; a central “apps” repo just declares `Application`/`ApplicationSet` objects.

Typical layout (one-repo, app-of-apps, Kustomize + optional Helm)

- `apps/`:
  - `*.yaml`: Argo CD `Application`/`ApplicationSet` specs for each component (infra and workloads)
  - Often includes a `root.yaml` (the “app of apps”) that points to subfolders
- `projects/`:
  - `*.yaml`: `AppProject` definitions (permissions, destinations, sources)
- `infra/`:
  - Infra add-ons as apps (ingress, cert-manager, monitoring, logging)
- `clusters/` (optional):
  - `ApplicationSet` to generate per-cluster apps from a cluster list/labels
- `services/<service>/` or `apps/<app>/`:
  - `base/`: Kustomize base (pure, env-agnostic manifests)
  - `overlays/<env>/`: Kustomize overlays with patches/vars per env (dev/stage/prod)
- `helm/` or `charts/` (optional):
  - Helm charts and `values-<env>.yaml` if Helm is used for templating

Practices and invariants
- Prefer base + overlays (Kustomize) or Helm with env-specific values; keep base reusable and minimal.
- Keep secrets out of plain text; commit encrypted (e.g., SOPS) or reference external secret managers.
- Use `AppProject` to restrict sources/destinations/namespaces and to group related apps.
- Ordering: use sync-waves and hooks annotations when dependencies must be sequenced.
- Multi-cluster: generate per-cluster apps via `ApplicationSet` (cluster generator) and label-based targeting.
- Validation pre-merge: run `kustomize build`/`helm template` + schema checks (e.g., kubeconform) in CI.
- Branching: `main` typically reflects production; overlays or directories handle env drift explicitly.
### Argo CD repository organization (concise, LLM-oriented)

Goal: A GitOps repo is the single source of truth for the desired state of one or more Kubernetes clusters. Argo CD pulls (not pushes), compares live vs. desired, and reconciles drift.

Core building blocks
- Applications: Argo CD `Application` objects point to a repo/path/revision and a destination cluster/namespace.
- ApplicationSets: Generate many `Application` objects from a template (e.g., per cluster, per environment, per directory).
- AppProjects: Group and guardrails for apps (allowed sources, destinations, namespaces, cluster-scoped resources).
- Manifests: Typically rendered by Kustomize or Helm, then applied by Argo CD.

Common repo patterns
- App-of-Apps: Root repo contains `Application`(s) that bootstrap all other apps (infra, platforms, business apps).
- Environment-centric: `environments/<env>/...` overlays drive per-env differences; often managed by an `ApplicationSet`.
- Per-app repos: Each app keeps its own manifests; a central “apps” repo just declares `Application`/`ApplicationSet` objects.

Typical layout (one-repo, app-of-apps, Kustomize + optional Helm)

- `apps/`:
  - `*.yaml`: Argo CD `Application`/`ApplicationSet` specs for each component (infra and workloads)
  - Often includes a `root.yaml` (the “app of apps”) that points to subfolders
- `projects/`:
  - `*.yaml`: `AppProject` definitions (permissions, destinations, sources)
- `infra/`:
  - Infra add-ons as apps (ingress, cert-manager, monitoring, logging)
- `clusters/` (optional):
  - `ApplicationSet` to generate per-cluster apps from a cluster list/labels
- `services/<service>/` or `apps/<app>/`:
  - `base/`: Kustomize base (pure, env-agnostic manifests)
  - `overlays/<env>/`: Kustomize overlays with patches/vars per env (dev/stage/prod)
- `helm/` or `charts/` (optional):
  - Helm charts and `values-<env>.yaml` if Helm is used for templating

Practices and invariants
- Prefer base + overlays (Kustomize) or Helm with env-specific values; keep base reusable and minimal.
- Keep secrets out of plain text; commit encrypted (e.g., SOPS) or reference external secret managers.
- Use `AppProject` to restrict sources/destinations/namespaces and to group related apps.
- Ordering: use sync-waves and hooks annotations when dependencies must be sequenced.
- Multi-cluster: generate per-cluster apps via `ApplicationSet` (cluster generator) and label-based targeting.
- Validation pre-merge: run `kustomize build`/`helm template` + schema checks (e.g., kubeconform) in CI.
- Branching: `main` typically reflects production; overlays or directories handle env drift explicitly.
